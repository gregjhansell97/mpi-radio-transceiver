#include "mpi_radio_transceiver.h"

// C
#include <string.h> // for copying raw memory

// STDLIB
#include <chrono>
#include <iostream>


// std namespace usage
using std::chrono::milliseconds;
using std::cout;
using std::endl;
using std::lock_guard;
using std::mutex;
using std::thread;
using std::unique_lock;

// hmap namespace usage
using hmap::interface::Communicator;

thread* MPIRadioTransceiver::mpi_listener_thread{nullptr};

#if 0
void MPIRadioTransceiver::mpi_listener(
        MPIRadioTransceiver* trxs, 
        const size_t trxs_size) {


    // TODO move "set_buffers" here for all transceivers

    // TODO: Move Datatype creation to external static function.
    // MPI meta information
    int rank = 0;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    // max_msg_size is the largest expected message
    const int max_msg_size = trxs[0].m_max_buffer_size;
    char* raw_msg;

    // mpi_msg will take in values from MPI calls
    //MPI_Msg* mpi_msg = new MPI_Msg;
    
    
    //struct {

    raw_msg = new char[trxs_size];




    // Set up creation of the MPI_Msg MPI Datatype.
    //const int block_counts = 3; // Number of blocks.
    // Data types contained in the struct.
    /*
    MPI_Datatype block_types[block_counts] = {
        MPI_INT, MPI_DOUBLE, MPI_CHAR};
    int block_lengths[block_counts] = { // Elements per block.
        2, 3, max_msg_size};
    MPI_Aint block_offsets[block_counts] = { // Byte displacement per block.
        offsetof(MPI_Msg, sender_rank),
        offsetof(MPI_Msg, sent_x),
        offsetof(MPI_Msg, data)
    };
    // Creates the MPI Datatype and commits.
    MPI_Datatype MPI_MSG_DT; // MPI wrapper for the MPI_Msg struct.
    MPI_Type_create_struct(
        block_counts, block_lengths, block_offsets, block_types, &MPI_MSG_DT);
    MPI_Type_commit(&MPI_MSG_DT);*/

    // set up Irecv requests
    const int RECV_INDEX = 0; // index for recv requests
    const int CLOSE_INDEX = 1; // index for close requests
    // Two types of requests: recv-requests and close-requests
    MPI_Request requests[2];

    // MPI received meta information
    MPI_Status status; // was the receive successful?
    int msg_size = 0; // how many bytes were received?
    char close_status = 0; // was the close clean?
    int channel; // the channel that became unblocked
    // Set up a non-blocking receive for the thread ending
    MPI_Irecv(
        &close_status, // was the close clean?
        1, // the close status is a 1-byte piece of data
        MPI_BYTE, // type of data being received
        rank, // the process will be receiving it from itself
        CLOSE_CHANNEL, 
        MPI_COMM_WORLD, // mpi-communicator used
        &requests[CLOSE_INDEX]); // request to block later on
    while(true) {
        // Each MPI message is going to need:
        // ========================================== HEADER
        // 1. a unique id (so you don't send to yourself)
        // 2. an x and a y location of the message sender
        // 3. the send-range
        // 4. length of message
        // ========================================== BODY
        // 5. the actual message
        MPI_Irecv(
            raw_msg, // would-be received data
            max_msg_size, // max size the received data can be
            MPI_BYTE, // type of data being received
            MPI_ANY_SOURCE, // Source of data being received (any communicator)
            RECV_CHANNEL, 
            MPI_COMM_WORLD, // mpi-communicator used
            &requests[RECV_INDEX]); // return to block later on
        MPI_Waitany(2, requests, &channel, &status);
        if(channel == CLOSE_CHANNEL) {
            // This is where clean up of local variables happen and any other
            // necessary closing down operations. This channel is messaged when
            // the rank is ending
            delete [] raw_msg;
            break;
        } else if(channel == RECV_CHANNEL) {
            // get size of the MPI msg
            MPI_Get_count(&status, MPI_BYTE, &msg_size);
            // Iterate through transceivers and load their mpi_msg buffers up
            // with new information (if it pertains to them, and their buffer
            // is not maxed out)
            // MPI_Msg* mpi_msg = (MPI_Msg*)(mpi_msg);
            for(size_t i = 0; i < trxs_size; ++i) {
                auto& t = trxs[i];
                // Check if mpi_msg buffer is maxed out; if so, drop message.
                // If the sender is itself, drop message.
                //if (t.m_buffer_size + msg_size > t.m_max_buffer_size
                //    || mpi_msg->sender_id == i) {
                //    continue;
                //} else 
                { // MPI_MSG BUFFER LOCK
                    // NOTE: this section is locked because the t.m_buffer
                    // can be modified (albeit only shrunken) by t.
                    // A potential optimization would be to skip for later 
                    // if can't get lock.
                    lock_guard<mutex> buffer_lock(t.m_buffer_mtx);
                    // move mpi_msg data to buffer on transceiver
                    memcpy(t.m_buffer + t.m_buffer_size, raw_msg, msg_size);
                    // adjust size
                    t.m_buffer_size += msg_size;
                    cout << "size: "<< t.m_buffer_size << endl;
                }
                // SHORT BUSY WAIT
                while(t.m_receiving) {
                    // ends any blocking mutexes
                    t.m_buffer_flag.notify_all();
                }
            }
        }
    }
}
#endif

/*bool MPIRadioTransceiver::open_mpi_listener(
        MPIRadioTransceiver* trxs,
        const size_t trxs_size) {
}*/

void MPIRadioTransceiver::close_mpi_listener() {
    // this is where the close message is sent
    // MPI meta information
    int rank = 0;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    // 0 is for success (only option atm)
    char closing_status = 0;
    MPI_Send(&closing_status, 1, MPI_BYTE, rank, CLOSE_CHANNEL, MPI_COMM_WORLD);
    // block until mpi_listener_thread dies
    mpi_listener_thread->join();
    delete mpi_listener_thread;
    mpi_listener_thread = nullptr;
}

void MPIRadioTransceiver::close_transceivers(
        MPIRadioTransceiver* trxs, const size_t trxs_size) {
    MPIRadioTransceiver::close_mpi_listener();
    for(size_t i = 0; i < trxs_size; ++i) {
        auto& t = trxs[i];
        t.close();
    }
}
    

MPIRadioTransceiver::MPIRadioTransceiver() { 
    int rank = 0;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    int num_ranks = 0;
    MPI_Comm_size(MPI_COMM_WORLD, &num_ranks);
    m_rank = rank;
    m_num_ranks = num_ranks;

}

ssize_t MPIRadioTransceiver::send(
        char* data, const size_t size, const int timeout) {
    if(size > m_max_buffer_size) {
        return Communicator::error;
    }
    // iterate through all ranks and send data
    // NOTE MPI_Bcast does not work for this because you need to know the 
    // root of the broadcaster ( all nodes are currently)
    for(size_t i = 0; i < m_num_ranks; ++i) {
        MPI_Send(data, size, MPI_BYTE, i, RECV_CHANNEL, MPI_COMM_WORLD);
    }
    return size;
}

ssize_t MPIRadioTransceiver::recv(char** data, const int timeout) {
    if(m_buffer_size == 0) {
        m_receiving = true;
        mutex mtx;
        unique_lock<mutex> lk(mtx);
        m_buffer_flag.wait_for(
                lk, // lock to block on  
                milliseconds(timeout), // time to wait on
                [this]{ return m_buffer_size > 0; }); // conditional to wait for
        m_receiving = false;
    }
    // now see if there is data in the buffer
    if(m_buffer_size > 0) { // there is data in the mpi msg buffer
        // Siphon off the received mpi msg off the buffer.
        //memcpy(m_buffer, m_recvd_msg, sizeof(MPI_Msg));
        *data = m_buffer; // this will do for now...
        m_receiving = false;
        return 1;
        // TODO Calculate actual size from data offsets (not MPI_Msg)
        // TODO Remove siphoned off message from buffer
        // TODO Shrink buffer size (need buffer_mtx for that)
        // TODO copy over buffer to newly re-allocated buffer memory
    } else {
        cout << "Nothing in buffer." << endl;
        return 0; // nothing in buffer and timeout reached
    }
}

void MPIRadioTransceiver::close() {
    // TODO
}

